* work out how to make a prompt work
* implement if/else/then to also work in interp mode -- see [IF] etc in spec
* maybe add another flag to say "is only available in compilation state" and add it to such
  words like IF etc that are meaningless in interpreted mode and possibly have edge cases.
  then make do_colon check the flag before trying to run them and if they shouldn't be run
  then just no-op (and maybe print a warning)  <- sorta done, but needs more thought
* maybe add another flag to say "is only available in interpret state" etc
* maybe add another flag to say "can't be postponed or [compiled]" ala TO
* debug primitives -- WORDS, DUMP, etc
* proper test suite built around ASSERT
* add a number-of-cells field to dictentry and hook everything up to know about it.
* actually hook up the memory stuff. this is going to require shifting to a function lookup table
  approach, because all of the user-defined xt's will change if the realloc moves the memory area.
* fix NUMBER (again) to deal with errno, endptr, etc sanely. eg 0 chars parsed means it's not a 
  number at all, so simply tell the caller as much
* add ['], FORGET
* move the do_foo() functions into vm.c so that builtin.c is only actual forth functions




add error states for stack underflow and stack overflow, and make the stack_* functions fire
them off -- or make them call abort? think about this
ok how about:
    when parameter stack overflows or underflows:
    1. reinitialise parameter stack to empty
    2. set error state and error message to something sensible
    3. call QUIT



memory sizes:

4mb of ram in ds

dictionary entry is 44bytes + data
=> absolute maximum entries that fit into memory is 4m / 44 is 95325 if NONE have any data
=> largest feasible number of dictionary entries 64k assuming average 5 cells of data each

        ad'ble  addr    eff min 64k xt  32k xt
align   loc'ns  size    size    tbl mem tbl mem
4       1M      20 bits 44B     160K    80K
16      256K    18 bits 48B     144K    72K
64      64K     16 bits 64B     128K    64K

but! if i have 64 byte alignment of dictionary entries, for a maximum of 65536 possible
addressable dictionary entries, then I can address the entirety of ram using 16 bits, which means
i don't need an XT lookup table at all, an XT is simply 1/64 addr/64.  to execute an xt, simply
multiply it by 64, add the start of memory offset, and call the DE at that address.

but! if i don't need an XT lookup table then there's also no necessity for an XT to be small,
because it's still going to be occupying a whole cell in the callers data region anyway.  so an XT
can simply remain a normal pointer to the code field.

I don't need to store the XT in the dictionary entry itself.  i only thought this was necessary
when i anticipated using an xt lookup table, and needed a sane way to work out the xt later on
when compiling new words.
